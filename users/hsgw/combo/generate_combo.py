import argparse
import csv
import os
import shutil

COPY_FILES = ["combo_util.h", "combo_util.c"]


def main():
    layers = []
    base_keys = []
    combos = []
    combo_name_count = {}

    parser = argparse.ArgumentParser(
        prog="Generate combo",
        usage="python generate_combo.py <csv file>",
        description="Generate QMK combo definition from csv file.",
        add_help=True,
    )

    parser.add_argument("csv", type=str, help="path to csv file")
    parser.add_argument("-prefix", type=str, help="prefix # default=CMB", default="cmb")
    parser.add_argument("-copyFiles", type=bool, help="copy files", default=False)
    parser.add_argument("-outDir", type=str, help="Output directory")

    args = parser.parse_args()

    csv_file_path = args.csv
    prefix = args.prefix
    out_dir = args.outDir

    if out_dir is None:
        out_dir = os.path.dirname(csv_file_path)

    with open(csv_file_path, "r") as csv_file:
        reader = csv.DictReader(csv_file)
        for row in reader:
            layer, keycode, combo = row["layer"], row["keycode"], row["combo"]
            if not all([layer, keycode, combo]):
                print("skipping wrong row", row)
                continue

            combo = combo.split(" ")
            # remove leading and trailing space, remove null elements
            combo = list(filter(None, list(map(str.strip, combo))))

            layer = layer.strip()
            if layer not in layers:
                layers.append(layer)

            keycode = keycode.strip()

            if len(combo) == 1:
                base_keys.append({"layer": layer, "keycode": keycode, "pos": combo[0]})
            elif len(combo) >= 2:
                keycode_name = keycode.replace("(", "_").replace(")", "")
                combo_name = f"{prefix}_{layer}_{keycode_name}".lower()
                count = combo_name_count.get(combo_name, 0)
                if count > 0:
                    combo_name = combo_name + f"_{count + 1}"
                    combo_name_count[combo_name] = count + 1
                else:
                    combo_name_count[combo_name] = 1

                combos.append(
                    {
                        "layer": layer,
                        "keycode": keycode,
                        "combo": combo,
                        "combo_name": combo_name,
                    }
                )
            else:
                print("skipping wrong row", row)
                continue

    if len(combos) == 0:
        print("no combos found")
        exit(1)

    with open(os.path.join(out_dir, "combos.h"), "w") as output:
        output.write("// generated by generate_combo.py\n\n")
        output.write('#pragma once\n\n#include "combo_util.h"\n\n')
        output.write(
            "#ifndef COMBO_LAYER_START\n#define COMBO_LAYER_START 0\n#endif\n\n"
        )
        output.write("// layers\n")
        output.write("enum combo_layers {\n")
        for i in range(len(layers)):
            output.write(f"  {prefix}_{layers[i]}".upper())
            if i == 0:
                output.write(" = COMBO_LAYER_START,\n")
            else:
                output.write(",\n")
        output.write("};\n\n")

        output.write("// define base keys\n")
        for key in base_keys:
            output.write(f'#define {key["layer"]}_{key["pos"]} {key["keycode"]}\n')
        output.write("\n")

        output.write("// define combos\n")
        output.write("enum combo_events {\n")
        for combo in combos:
            output.write(f'  {combo["combo_name"]},\n'.upper())
        output.write("};\n\n")

        for combo in combos:
            output.write("const uint16_t PROGMEM ")
            output.write(f'{combo["combo_name"]}[] = {{')
            for pos in combo["combo"]:
                output.write(f'{combo["layer"]}_{pos},')
            output.write("COMBO_END};\n")
        output.write("\n")

        # output.write("combo_t key_combos[] = {\n")
        # for combo in combos:
        #     output.write(f'  [{combo["combo_name"].upper()}] = ')
        #     output.write(f'COMBO({combo["combo_name"]}, {combo["keycode"]}),\n')
        # output.write("};\n\n")

        output.write("#define __KEY_COMBOS_DEF__ \\\n")
        for i in range(len(combos)):
            output.write(f'[{combos[i]["combo_name"].upper()}]=')
            output.write(f'COMBO({combos[i]["combo_name"]}, {combos[i]["keycode"]})')
            if i == len(combos) - 1:
                output.write("\n")
            else:
                output.write(",\\\n")
        output.write("\n")

    print("generated combos.h")

    # copy files
    if args.copyFiles:
        for file in COPY_FILES:
            shutil.copy2(
                os.path.join(os.path.dirname(__file__), file),
                os.path.join(out_dir, file),
            )
            print(f"copied {file}")

    print("done")

    exit(0)


if __name__ == "__main__":
    main()
